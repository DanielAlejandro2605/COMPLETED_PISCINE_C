#include <stdio.h>
#include <stdlib.h>

int main(void)
{

///////////////////////////////////////////////////////////////////////////////
    /* Имя массива без индексов в Си является адресом его первого элемента. 
    
    1) Данные можно получить по точному индексу обращаясь как массиву так ->  arr[0] или   arr[0][0](если массив двухмерный) 
    или обращаясь как указателю через операции разыменовывания        -> *arr    или  *arr[i](если массив двухмерный) когда обращение идет минуя первый индекс просто подразумевая его исходя из его адреса -> arr или arr[i](если массив двухмерный); 

    2) Адрес можно получить по точному индексу обращаясь как массиву ->  &arr[0] или   &arr[0][0](если массив двухмерный)           или обращаясь как указателю   ->   arr    или    arr[i]   (если массив двухмерный) */

    /* Массив символов можно обьявить по разному но по значению они будут идентичны: */
///////////////////////////////////////////////////////////////////////////////
    char welcome[] = {'H', 'e', 'l', 'l', 'o', '\0'};
    char welcome1[6] = {'H', 'e', 'l', 'l', 'o', '\0'};

    char welcome2[] = "Hello";
    char welcome3[6] = "Hello";
    
    char *welcome4 = "Hello";

    int aa[] = {1, 2, 3, 4, 5};
    int a1[6] = {1, 2, 3, 4, 5, 6};
    int a2[][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
    int arr[2][3][4] = {{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}},{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}}};

    char fruit0[][8] = {"apricot", "apple", "banana", "lemon", "pear", "plum"};
    char *fruit1[] = {"apricot", "apple", "banana", "lemon", "pear", "plum"};

    int q = sizeof(arr) / sizeof(arr[0]);       // число строк
    int w = sizeof(arr[0]) / sizeof(arr[0][0]); // число столбцов
    int t = sizeof(fruit1) / sizeof(fruit1[0]);   // число строк
///////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
    for (int i = 0; i < 5; i++)
    {   
        //Так как здесь массив одномерный[], то адресом первого элемента будет "a"
        printf("a[%d]: address=%p \t value=%d \n", i, aa + i, *(aa + i)); 
        printf("a[%d]: address=%p \t value=%d \n", i, &aa[i], aa[i]);

        //Так как здесь массив двухмерный[][], то адресом первого элемента будет "a[0]"
        printf("a[%d]: address=%p \t value=%d \n", i, a2[0] + i, *(a2[0] + i));
        printf("a[%d]: address=%p \t value=%d \n", i, &a2[0][i], a2[0][i]);

        //Так как здесь массив трехмерный[][][], то адресом первого элемента будет "a[0][0]"
        printf("a[%d]: address=%p \t value=%d \n", i, arr[0][0] + i, *(arr[0][0] + i));
        printf("a[%d]: address=%p \t value=%d \n", i, &arr[0][0][i], arr[0][0][i]);
    }
///////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
    printf("%p \t", arr);       // ->address = 0x7ffe8d7389e4
    printf("%d \t", *arr);      // ->a[0] = 1
    printf("%p \t", &arr);      // ->address = 0x7ffe8d7389e4
    
    printf("%d \t", arr[0]);    // ->a[0] = 1
///////////////////////////////////////////////////////////////////////////////
    printf("%s ", welcome);         // ->Hello
    printf("%c ", welcome[2]);      // ->l
///////////////////////////////////////////////////////////////////////////////
    for (int i = 0; i < 6; i++)
        printf("%d ", welcome[i]);  /* 72 101 108 108 111 0 */
///////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
//      #include <stdio.h>
///////////////////////////////////////////////////////////////////////////////
// Функция twice в качестве параметров принимает массив и число его элементов и в цикле увеличивает их в два раза.
///////////////////////////////////////////////////////////////////////////////
//      void twice(int n, int p[])
//      {
//          for (int i = 0; i < n; i++)
//          {
//              p[i] *= 2;   // ИЛИ ТАК -> *(p+i) *= 2;
//          }
//       }
///////////////////////////////////////////////////////////////////////////////
// Так как передача массива в функцию фактически представляет передачу адреса первого элемента, то массивы в параметрах мы можем заменить указателями:
///////////////////////////////////////////////////////////////////////////////
//       void twice2(int n, int *p)
//       {
//           for(int i=0; i<n; i++)
//           {
//               *p++ *= 2;
//           }
//       }   
///////////////////////////////////////////////////////////////////////////////
// Используем обе эти функции в методе "main"
////////////////////////////////////////////////////////////////////////////////
//       int main(void)
//       {
//           int arr[] = {1, 2, 3, 4};
//           int length = sizeof(nums)/sizeof(nums[0]);

//           twice(length, arr);   ->   2   4   6   8   10
//           twice2(length, arr);  ->   2   4   6   8   10

//           printf("%p \t", arr);
//           printf("%d \t", arr[0]);
//           printf("%p \t", &arr);
//           printf("%d \t", *arr);

//        return 0;

//       }
///////////////////////////////////////////////////////////////////////////////















///////////////////////////////////////////////////////////////////////////////
    /* Имя массива без индексов в Си является адресом его первого элемента. Соответственно через операцию разыменования мы можем получить значение по этому адресу: */
///////////////////////////////////////////////////////////////////////////////
    int a[] = {1, 2, 3, 4, 5};

    printf("a[0] = %d", *a); // a[0] = 1

    for (int i = 0; i < 5; i++)
    {
        printf("a[%d]: address=%p \t value=%d \n", i, a + i, *(a + i));
    }
///////////////////////////////////////////////////////////////////////////////
    /* Мы можем пробежаться по всем элементом массива, прибавляя к адресу определенное число.
    То есть, например, адрес второго элемента будет представлять выражение a+1, а его значение - *(a+1).
    Со сложением и вычитанием здесь действуют те же правила, что и в операциях с указателями. Добавление единицы означает прибавление к адресу значения, которое равно размеру типа массива. Так, в данном случае массив представляет тип int, размер которого, как правило, составляет 4 байта, поэтому прибавление единицы к адресу означает увеличение адреса на 4. Прибавляя к адресу 2, мы увеличиваем значение адреса на 4 * 2 =8. И так далее. */
///////////////////////////////////////////////////////////////////////////////






///////////////////////////////////////////////////////////////////////////////
    /* В то же время имя массива это не стандартный указатель, мы не можем изменить его адрес, например, так: */
///////////////////////////////////////////////////////////////////////////////
    int ca[5] = {1, 2, 3, 4, 5};
    // a++;            // так сделать нельзя
    int b = 8;
    // a = &b;         // так тоже сделать нельзя
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
    /* Имя массива всегда хранит адрес самого первого элемента. И нередко для перемещения по элементам массива используются отдельные указатели: */
///////////////////////////////////////////////////////////////////////////////
    int a[5] = {1, 2, 3, 4, 5};

    int *ptr = a;

    int a2 = *(ptr + 2);

    printf("value: %d \n", a2); // 3
///////////////////////////////////////////////////////////////////////////////
    /* Здесь указатель ptr изначально указывает на первый элемент массива. Увеличив указатель на 2, мы пропустим 2 элемента в массиве и перейдем к элементу a[2]. */
///////////////////////////////////////////////////////////////////////////////













///////////////////////////////////////////////////////////////////////////////
    /* С помощью указателей легко перебрать массив: */
///////////////////////////////////////////////////////////////////////////////
    int a[5] = {1, 2, 3, 4, 5};

    for (int *ptr = a; ptr <= &a[4]; ptr++)
    {
        printf("address=%p \t value=%d \n", ptr, *ptr);
    }
///////////////////////////////////////////////////////////////////////////////
    /* Так как указатель хранит адрес, то мы можем продолжать цикл, пока адрес в указателе не станет равным адресу последнего элемента. */
///////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////
    /* Аналогичным образом можно перебрать и многомерный массив: */
///////////////////////////////////////////////////////////////////////////////
    int arr[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};

    int n = sizeof(arr) / sizeof(arr[0]); // число строк

    int m = sizeof(arr[0]) / sizeof(arr[0][0]); // число столбцов

    int *final = arr[0] + n * m - 1; // указатель на самый последний элемент

    for (int *ptr = arr[0], i = 1; ptr <= final; ptr++, i++)
    {
        printf("%d \t", *ptr);
        // если остаток от целочисленного деления равен 0,
        // переходим на новую строку
        if (i % m == 0)
        {
            printf("\n");
        }
    }
///////////////////////////////////////////////////////////////////////////////
    /* Так как в данном случае мы имеем дело с двухмерным массивом, то адресом первого элемента будет выражение a[0]. Соответственно указатель указывает на этот элемент. С каждой итерацией указатель увеличивается на единицу, пока его значение не станет равным адресу последнего элемента, который хранится в указателе final. */
///////////////////////////////////////////////////////////////////////////////










///////////////////////////////////////////////////////////////////////////////
    /* Мы также могли бы обойтись и без указателя на последний элемент, проверяя значение счетчика: */
///////////////////////////////////////////////////////////////////////////////
    int a[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};

    for (int *ptr = a[0], i = 0; i < m * n;)
    {
        printf("%d \t", *ptr++);
        if (++i % m == 0)
        {
            printf("\n");
        }
    }
///////////////////////////////////////////////////////////////////////////////
    return 0;
}