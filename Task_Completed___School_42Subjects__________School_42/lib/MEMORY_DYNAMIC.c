///////////////////////////////////////////////////////////////////////////////
// При создании массива с фиксированными размерами под него выделяется определенная память. Например, пусть у нас будет массив с пятью элементами:
///////////////////////////////////////////////////////////////////////////////
              double numbers[5] = {1.0, 2.0, 3.0, 4.0, 5.0};
///////////////////////////////////////////////////////////////////////////////
// Для такого массива выделяется память 5 * 8 (размер типа double) = 40 байт. Таким образом, мы точно знаем, сколько в массиве элементов и сколько он занимает памяти. Однако это не всегда удобно. Иногда бывает необходимо, чтобы количество элементов и соответственно размер выделяемой памяти для массива определялись динамически в зависимости от некоторых условий. Например, пользователь сам может вводить размер массива. И в этом случае для создания массива мы можем использовать динамическое выделение памяти.
///////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////
// Для управления динамическим выделением памяти используется ряд функций, которые определены в заголовочном файле stdlib.h:
///////////////////////////////////////////////////////////////////////////////
//                       malloc(). Имеет прототип
///////////////////////////////////////////////////////////////////////////////
                    void *malloc(unsigned s);


                          malloc(n * sizeof(int));
// Выделяет память длиной в s байт и возвращает указатель на начало выделенной памяти. В случае неудачного выполнения возвращает NULL
///////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
//                       calloc(). Имеет прототип
///////////////////////////////////////////////////////////////////////////////
                    void *calloc(unsigned n, unsigned m);


                          calloc(n, sizeof(int));
// Выделяет память для n элементов по m байт каждый и возвращает указатель на начало выделенной памяти. В случае неудачного выполнения возвращает NULL
///////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
//                       realloc(). Имеет прототип
///////////////////////////////////////////////////////////////////////////////
                    void *realloc(void *bl, unsigned ns);


                          realloc (block, n * sizeof(int));
// Изменяет размер ранее выделенного блока памяти, на начало которого указывает указатель bl, до размера в ns байт. Если указатель bl имеет значение NULL, то есть память не выделялась, то действие функции аналогично действию malloc
                    int *block = NULL;
                    block = realloc (block, n * sizeof(int));
// При использовании realloc желательно (в некоторых средах, например, в Visual Studio, обязательно) инициализировать указатель хотя бы значением NULL.
///////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
//                       free(). Имеет прототип
///////////////////////////////////////////////////////////////////////////////

                    void *free(void *bl);
                    
// Освобождает ранее выделенный блок памяти, на начало которого указывает указатель bl.
// Если мы не используем эту функцию, то динамическая память все равно освободится автоматически при завершении работы программы. Однако все же хорошей практикой является вызов функции free(), который позволяет как можно раньше освободить память.
///////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#include <stdlib.h>
#include <stdio.h>

int main(void)
{ 
    int *block; // указатель для блока памяти
    int n;      // число элементов массива
    // ввод числа элементов
    printf("Size of array=");
    scanf("%d", &n);
    
    // выделяем память для массива
    // функция malloc возвращает указатель типа void*
    // который автоматически преобразуется в тип int*
    block = malloc(n * sizeof(int));

    // вводим числа в массив
    for(int i=0;i<n; i++)
    {
        printf("block[%d]=", i);
        scanf("%d", &block[i]);
    }
    printf("\n");

    // вывод введенных чисел на консоль
    for(int i=0;i<n; i++)
    {
        printf("%d \t", block[i]);
    }
    
    // освобождаем память
    free(block);  // Важно, что после выполнения этой функции мы уже не сможем использовать массив, например, вывести его значения на консоль
    
    return 0;
}







///////////////////////////////////////////////////////////////////////////////
// Теперь рассмотрим более сложную задачу - динамическое выделение памяти для 
// двухмерного массива:
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
 
int main(void)
{
    int **table;    // указатель для блока памяти для массива указателей
    int *rows;      // указатель для блока памяти для информации по строкам
 
    int rowscount;  // количество строк
    int d;      // вводимое число
     
    // ввод количества строк
    printf("Rows count=");
    scanf("%d", &rowscount);
 
    // выделяем память для двухмерного массива
    table = calloc(rowscount, sizeof(int*));  //память для массива указателей
    rows = malloc(rowscount * sizeof(int));   //память для информации по строкам

    // цикл по строкам
    for (int i = 0; i<rowscount; i++)
    {
        printf("\nColumns count for row %d=", i);
        scanf("%d", &rows[i]);
        table[i] = calloc(rows[i], sizeof(int));

        for (int j = 0; j<rows[i]; j++)
        {
            printf("table[%d][%d]=", i, j);
            scanf("%d", &d);
            table[i][j] = d;
        }
    }
    printf("\n");
 

 
    // вывод введенных чисел на консоль
    for (int i = 0; i<rowscount; i++)
    {
        printf("\n");
 
        for (int j = 0; j<rows[i]; j++)
        {
            printf("%d \t", table[i][j]);
        }
        // освобождение памяти для одной строки
        free(table[i]);
    }
     
    // освобождение памяти
    free(table);
    free(rows);
 
    return 0;
}





///////////////////////////////////////////////////////////////////////////////
// Сложим два массива, с помощью специальной функции
///////////////////////////////////////////////////////////////////////////////
// Преимуществом использования указателя как возвращаемого типа является то, 
// что это позволяет получать из функции набор значений, в частности, массив.
#include <stdio.h>
#include <stdlib.h>
 
int *addArrays(int a[], int b[], int n) 
{
    int *ptr = calloc(n, sizeof(int)); 
 
     for (int i = 0; i < n; i++)
        ptr[i] = a[i] + b[i];
 
     return ptr;
}
 
int main(void)
{
    int a[] = {3,4,5,6,7};
    int b[] = {1,1,1,1,1};
 
    int n = sizeof(a)/sizeof(a[0]);
    int *ptr = addArrays(a, b, n);
    for(int i=0;i<n;i++)
        printf("%d \t", *ptr++);   //   *ptr+i  ptr[i]
    free(ptr);
    return 0;
}

