/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_print_address.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: evgenkarlson <RTFM@42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/02/14 12:33:14 by evgenkarlson      #+#    #+#             */
/*   Updated: 2020/09/28 15:47:04 by evgenkarlson     ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/ft_lib.h"

/* Функция печати адреса первого символа строки */
void ft_print_address(int nbr, char *hex)	/* Принимает в параметры число указывающее порядковый номер адрес относительно начала
											 * и адрес строки с символами нужной нам системы счисления */
{
	int		add[9];											
	int 	i;							/* обьявляем счетчик для подсчета количества найденых символов*/
	int		j;							/* обьявляем переменную для вычисления значения показывающего сколько раз нужно печатать символ нуля перед самим адресом */
	int 	base_type;					/* обьявляем переменную для хранения информации о системе счисления */

	i = 0;								/* инициализируем счетчик найденых символов нулем */
	j = 8;								/* инициализируем счетчик заполнения пустых ячеек числом 8 на случай если адресс равен нулю */
	base_type = 16;						/* записываем в переменную для хранения сисстемы счисления число 16 перевода данных в  шестнадцатиричную систему */
	if(nbr == 0)						/* Если порядковый номер указывающий на адресс равен нулю */
		while(j-- > 0)					/* Значит запускаем цикл печатающий 8 символов и завершаем функцию */
			ft_putchar('0');
	else
	{
		while (nbr)						/* пока значение переменной хранящей число не равно нулю */
		{
			add[i] = nbr % base_type;	/* ВЫЧИСЛЯЕМ с помощью base_size ТО, как в нужной нам системе счисления выглядит число.
										** Для этого делим nbr на base_size по модулю и записывая результат в массив начиная с первой ячейки.
										** Так мы узнаем значение крайнего символа в нужной нам системе счисления */

			nbr /= base_type;			/* Теперь для вычисления оставшихся чисел уменьшаем само число в nbr, разделив его на 
										** размер base_size (размер нужного нам базового типа) и сохраняем результат в той же переменной nbr */

			i++;						/* Увеличиваем счетчик для перехода к след ячейке. Так же переменная i нам понадобиться позже. 
										** Накопленное в ней значение скажет нам о размере получившегося массива, которое мы используем 
										** чтобы напечатать символы в правильном порядке. */
		}
		j = (8 - i);					/* узнаем сколько еще осталось места в выводе где должны быть напечатаны симолы */
		while(j-- > 0)					/* Запускаем цикл заполяющий нулями пустые места, которые должны быть заняты или числом или нулями */
			ft_putchar('0');
		while (i > 0)						/* Запускаем цикл который напечатает все найденные нами и записанные в массив 'add' значения символов начиная с конца */
			ft_putchar(hex[add[--i]]);	/* Для этого мы используем массив с каждым найденным нами числом, как указатель на ячеку массива в котрой храниться его значение.
										** Вызывать числа из массива 'add' и вставлять как указательна нужное значение мы будем в обратном порядке.
										** Начиная с конца массива и двигаясь к его началу, чтобы восстановить порядок найденых нами символов */
	}
	ft_putchar(':');					/* После печати адреса в hex печатаем двоеточие */
	ft_putchar(' ');					/* И пробел, и завершаем функцию  */
}